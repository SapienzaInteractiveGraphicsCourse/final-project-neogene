<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andrea Leganza - 788513</title>
    <script src="js/tween/tween.umd.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.144.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.144.0/examples/jsm/",
                "three/post/": "https://unpkg.com/three@0.144.0/examples/js/postProcessing/",
                
                "GUI": "./Libs/datgui/dat.gui.module.js",
                "OrbitControls": "https://unpkg.com/three@0.144.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <style>
        body {
            background-color: black;   
        }
    </style>
</head>
<body>

<script type="module">

    import * as THREE from 'three';

    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'OrbitControls';
    import { GUI } from 'GUI'

    import { EffectComposer } from  'https://threejs.org/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from      'https://threejs.org/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://threejs.org/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { BokehPass } from       'https://threejs.org/examples/jsm/postprocessing/BokehPass.js';
    import { Water } from           'https://threejs.org/examples/jsm/objects/Water.js';
    import { Sky } from             'https://threejs.org/examples/jsm/objects/Sky.js';

    const FogMode = {
        none : 0,
        linear : 1,
        exp : 2
    }

    const AntialiasMode = {
        off : false,
        on : true
    }

    const ShadowMode = {
        off : false,
        on : true
    }

    const GridMode = {
        off : false,
        on : true
    }

    const SkyMode = {
        off : 0,
        embedded : 1,
        custom : 2
    }

    const SkyTime = {
        day : true,
        night: false
    }

    const DebugMode = {
        off : false,
        on  : true
    }

    const GrassMode = {
        off : false,
        on  : true
    }

    const GUIMode = {
        off : false,
        on  : true
    }

    const PostProcessingMode = {
        off : false,
        on  : true
    }

    const NightMode = {
        off : false,
        on  : true
    }

    const WindowsLightMode = {
        off : false,
        on  : true
    }

    const SceneMode = {
        off : false,
        on  : true
    }

    //Needed to make raw animation code time indipentend
    var clock = new THREE.Clock();
    var deltaTime;

    //Settings
    var debugMode = DebugMode.off
    var nightMode = NightMode.on
    var gridMode = GridMode.off
    var fogMode = FogMode.linear
    var antialias = AntialiasMode.on
    var shadowsMode = ShadowMode.on
    var lightsShadow = ShadowMode.on
    var skyMode = SkyMode.embedded
    var grassMode = GrassMode.on
    var gui = GUIMode.on
    var postProcessingMode = PostProcessingMode.on;
    var skyTime = SkyTime.day; 
    var windowsLightMode = WindowsLightMode.off;
    var sceneMode = SceneMode.on
    var skybox;
    var skyEmbedded;
    var sea;
    var grid;
    
    var sky;
    var sun;
    var water;

    var phoenix
    var phoenixGroup;
    
    //Ligths
    var ambientLight;
    var spotLight;
    var torchLights = []
    var torchLightsTweens = []

    //Self emitting light meshes
    var emissiveMeshes = []

    //Post processing
    const bloomParams = {
        exposure: 1,
        bloomStrength: 0.4,
        bloomThreshold: 0,
        bloomRadius: 0
    };

    const bokehParams = {
        focus : 170,
        aperture : 1.5,
        maxblur : 0.01,
        width : window.innerWidth,
        height : window.innerHeight
    }

    var composer;
    const postProcessing = {};

    const WINDOWS_EMISSIVE_VALUE = 100;
    const PHOENIX_EMISSIVE_VALUE = 10;

    const animationsObjects = [];

    //Quaternion
//   let quaternion = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3(0, 0, 1).normalize(), 0.5 );

    //Renderer
    const renderer = new THREE.WebGLRenderer({antialias: antialias}); 
    renderer.setSize( window.innerWidth, window.innerHeight ); 
    renderer.shadowMap.enabled = shadowsMode;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.autoClear = false;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.LinearToneMapping;
    document.body.appendChild( renderer.domElement );

    //Scene
    const scene = new THREE.Scene(); 

     //Camera
    const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 ); 
    camera.far = 100;
    camera.position.y = 1.57;
    camera.position.z = 10;
    
    //Camera Controls
    const controls = new OrbitControls( camera, renderer.domElement );
    controls.keyPanSpeed = 10;
    controls.panSpeed = 1;
    controls.rotateSpeed = 1;
    controls.zoomSpeed = 1;
    controls.autoRotate = false;
    controls.minDistance = 5;
    controls.maxDistance = 10;
    controls.maxPolarAngle = THREE.MathUtils.degToRad(80); 
    //Must be called after any manual changes to the camera's transform
    controls.update() //mandatory

    //Scene setup
    placeFog(scene,fogMode)

    //Global light
    ambientLight = new THREE.AmbientLight(0xffffff)
    ambientLight.intensity = 0.7;
    scene.add(ambientLight);

    if (skyMode == SkyMode.custom){
        placeSkyBox(scene,skyTime);
    }

    //Boat
    var boatGroup;

    //Support
    if (gridMode){ 
       placeGrid(gridMode);
    }

    //water
    sky = placeSky(scene);
    sun = placeSun(sky,scene);
    water = placeWater(scene);
    animateWater(water)

    //Local light
    spotLight = new THREE.SpotLight(0xd4d49c, 3);
    spotLight.position.set(0, 5, 1.4);
    spotLight.castShadow = lightsShadow;
    spotLight.penumbra = 0.05;
    spotLight.intensity = 3;
    spotLight.distance = 10;
    spotLight.angle = 0.7;
    spotLight.target = water; //target has to be added before this command
    scene.add(spotLight);
    
    loadEnvironment()

//SUPPORT FUNCTIONS

    function loadEnvironment(){
        const loader = new GLTFLoader();

        loader.load( '3D/seaport/scene.gltf', function ( gltf ) {
            gltf.scene.scale.set(0.01, 0.01, 0.01);
            gltf.scene.traverse((o) => {
                
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;

                    if (debugMode){
                        console.log("Loading mesh: "+o.name);
                    }
                    if (o.name == "Sky_Sky_0"){
                        skyEmbedded = o;
                        const text = skyTime == SkyTime.day ? "material_4_baseColor" : "material_4_baseColor_night";
                        const textureName = '3D/seaport/textures/'+text+'.jpg';

                        skyEmbedded.material.map = new THREE.TextureLoader().load( textureName );
                        skyEmbedded.material.needsUpdate = true;
                        skyEmbedded.visible = skyMode == SkyMode.embedded;
                    }
                    else if (o.name == "Environment"){
                        const groundNormalTexture = new THREE.TextureLoader().load( '3D/seaport/textures/Environment_normal.png' , function ( texture ) {
                            o.material.normalMap = texture
                            o.material.normalScale = new THREE.Vector3( 1, 1 );
                        });
                    }
                    else if (o.name == "Sea_sea_0"){
                        sea = o;
                    }
                    else if (o.name.toLowerCase().includes("torch")){
                        placeTorchLight(o);
                    }

                    if (o.material.emissiveMap!=null && o.name == "Tower") {
                        if (debugMode){
                            console.log("Fixing emissive for: "+o.name);
                        }

                        if (windowsLightMode == WindowsLightMode.on){
                            o.material.emissiveIntensity = WINDOWS_EMISSIVE_VALUE; //increase windows lights
                        }

                        emissiveMeshes.push (o);
                    }
                    //if required
                    //o.material.normalScale.y *= -1;
                }
            });

            if (sceneMode == SceneMode.on){
                scene.add( gltf.scene );
            }

            loadBoat()

        }, undefined, function ( error ) {

            console.error( error );

        } );
    }

//BOAT
    function loadBoat(){
        const loader = new GLTFLoader();

        loader.load( '3D/boat/boat.gltf', function ( gltf ) {
            gltf.scene.scale.set(0.1, 0.1, 0.1);
            gltf.scene.position.set(5,0,-0.1);
            gltf.scene.traverse((o) => {
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;

                    if (debugMode){
                        console.log("Loading mesh: "+o.name);
                    }
                  
                    if (o.name == "Torch"){
                        placeTorchLight(o,true, false, 0, false, false); //parent, visible, animate, deltaZ, addmesh, addtotorches
                        oscillateBoatTorch(o);
                    }
                    else if (o.name == "Body"){
                        const groundNormalTexture = new THREE.TextureLoader().load( '3D/boat/textures/Image-Image_n.png' , function ( texture ) {
                            o.material.normalMap = texture
                            o.material.normalScale = new THREE.Vector3( 1, 1 );

                            if (debugMode){
                                console.log("Applying normal map to: "+o.name);
                            }
                        });
                    }
                    else if (o.name == "Hull"){
                        const groundNormalTexture = new THREE.TextureLoader().load( '3D/boat/textures/Image_n.png' , function ( texture ) {
                            o.material.normalMap = texture
                            o.material.normalScale = new THREE.Vector3( 1, 1 );

                            if (debugMode){
                                console.log("Applying normal map to: "+o.name);
                            }
                        });
                    }

                    if (o.material.emissiveMap!=null) {
                        if (debugMode){
                            console.log("Fixing emissive for: "+o.name);
                        }

                        if (windowsLightMode == WindowsLightMode.on){
                            o.material.emissiveIntensity = WINDOWS_EMISSIVE_VALUE; //increase windows lights
                        }
                        emissiveMeshes.push (o);
                    }
                }
            }
            )
            
            boatGroup = new THREE.Group();
            boatGroup.position.z = 0;
            boatGroup.rotation.y = Math.PI*3/2;
            boatGroup.rotation.x = Math.PI / 2;
            boatGroup.add( gltf.scene );
            water.add( boatGroup );
            
            loadPhoenix()
        })
    }

    function endLoadingMeshes(){
        //GUI
        if (gui){
                placeGUI(scene, renderer, camera, controls, false);
            }

        //Post processing
        if (postProcessingMode){
            setupPostProcessing(renderer);
        }

        //we can now start the whole engine
        animate();
    }

    //BOAT
    function loadPhoenix(){
        const loader = new GLTFLoader();

        loader.load( '3D/phoenix/phoenix.gltf', function ( gltf ) {
            gltf.scene.position.set(0,1,5);
            //gltf.scene.rotation.set(0,-Math.PI/2,0);
            gltf.scene.traverse((o) => {
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;

                    if (debugMode){
                        console.log("Loading mesh: "+o.name + " data (axis: "+o.userData.axis+" prop: "+o.userData.prop+")");
                    }

                    if (o.userData.axis!=null){
                        animatePhoenixMesh(o,o.userData.axis,o.userData.prop, o.userData.delay, o.userData.easing)
                    }

                    if (o.material.emissiveMap!=null) {
                        if (debugMode){
                            console.log("Fixing emissive for: "+o.name);
                        }

                        if (windowsLightMode == WindowsLightMode.on){
                            o.material.emissiveIntensity = PHOENIX_EMISSIVE_VALUE; //increase windows lights
                        }
                        emissiveMeshes.push (o);
                    }
                }
            }
            )
            
            phoenix = gltf.scene.getObjectByName("Body");

            phoenixGroup = new THREE.Group();
            phoenixGroup.add( gltf.scene );
            
            scene.add( phoenixGroup );

            loadPhoenixPath();
            
            endLoadingMeshes();
        })
    }

    var tangent = new THREE.Vector3();
    var axis = new THREE.Vector3();
    var up = new THREE.Vector3( 1, 0, 0 )
    var counter = 0;
    var spline;

    function loadPhoenixPath(){

        if (debugMode){
            console.log("Loading phoenix path");
        }

        spline = new THREE.CatmullRomCurve3( [
        new THREE.Vector3( -1 , 1, -1),
        new THREE.Vector3( -1.2 , 1, 1.1),
        new THREE.Vector3( 0.8 , 1, 1),
        new THREE.Vector3( 1 , 1, -1.1),
    ] , true );

        if (debugMode){
            const points = spline.getPoints( 30 );
            const geometry = new THREE.BufferGeometry().setFromPoints( points );

            const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

            // Create the final object to add to the scene
            const splineObject = new THREE.Line( geometry, material );
        // splineObject.rotation.x = Math.PI*0.5

            scene.add(splineObject)
        }
    }

    
    function animatePhoenixMesh(mesh, axis, delta, delay, easing){

        if (debugMode){
            console.log("Animating phoenix: "+mesh.name);
        }

        const tween = new TWEEN.Tween(mesh.rotation)
            .to({[axis]:mesh.rotation[axis] + 0.2*delta},1000)
            .yoyo(true)
            .delay(delay != null ? delay*1000 : 0)
            .repeat(Infinity)
            .easing(easing != null ? (easing == 1 ? TWEEN.Easing.Linear.None : TWEEN.Easing.Quadratic.InOut) : TWEEN.Easing.Linear.None)
            /*.onUpdate(function () {
              
            })*/
            .start()
    
    }

    function movePhoenixAroundPath(delta) {
        if (counter <= 1) {
            const p = spline.getPointAt(counter);

            phoenixGroup.position.set(p.x,p.y,p.z);
            
            tangent = spline.getTangentAt(counter).normalize();

            axis.crossVectors( up, tangent ).normalize();

            var radians = Math.acos( up.dot( tangent ) );

            phoenixGroup.quaternion.setFromAxisAngle( axis, radians );

            /*if (debugMode){
                console.log("Animating phoenix: "+phoenixGroup.position.x+ ","+phoenixGroup.position.y+","+phoenixGroup.position.z+" rad:"+radians);
           }*/
            counter += delta
        } else {
            counter = 0;
        }
    }


    function animateTorchLight(light, mesh, autoStart = false){
        if (debugMode){
            console.log("Animating torch light: "+light.parent);
        }
        const tween = new TWEEN.Tween(light)
            .to({intensity: 0}, ( Math.random()) * 3000 + 1000)
            .yoyo(true)
            .repeat(Infinity)
            .easing(TWEEN.Easing.Circular.InOut);
            
            if (autoStart) tween.start();

            torchLightsTweens.push(tween)


        if (mesh!=null){
            const tweenFire = new TWEEN.Tween(mesh.scale)
                .to({x: mesh.scale.x+0.1, y: mesh.scale.y+0.3, z: mesh.scale.z+0.5}, ( Math.random()) * 1000 + 1000)
                .yoyo(true)
                .repeat(Infinity)
                .easing(TWEEN.Easing.Linear.None);
                
                if (autoStart) tweenFire.start();

                torchLightsTweens.push(tweenFire)
        }
    }

    function oscillateBoatTorch(mesh){
        if (debugMode){
            console.log("Oscillating mesh: "+mesh.name);
        }
        
        const tween = new TWEEN.Tween(mesh.rotation)
            .to({x:mesh.rotation.x + Math.PI / 5},4000)
            .yoyo(true)
            .repeat(Infinity)
            .easing(TWEEN.Easing.Quadratic.InOut)
            /*.onUpdate(function () {
              
            })*/
            .start()
    }

    //render loop
    var totalTime;
    function animate() {
        deltaTime = clock.getDelta();
        totalTime+=deltaTime;

        controls.update();
        
        animationsObjects.forEach(mesh => {
            if (mesh.userData.clock && mesh.userData.mixer) {
                mesh.userData.mixer.update(mesh.userData.clock.getDelta());
            }
        })

        if (skyEmbedded!=null && skyEmbedded.visible) {
            skyEmbedded.rotation.z += 0.01*deltaTime; 
            //sky.position.applyQuaternion(quaternion);
        }
        
        water.material.uniforms[ 'time' ].value += 0.1*deltaTime;

        if (boatGroup!=null) {
            boatGroup.rotation.y += 0.02*deltaTime;
        }

        requestAnimationFrame( animate );
        postProcessingMode ? postProcessing.composer.render(deltaTime) : renderer.render( scene, camera );
        TWEEN.update();

        movePhoenixAroundPath(deltaTime*0.05);
    }

    function placeWater(scene) {
        const waterGeometry = new THREE.PlaneGeometry(20, 20);
        const water = new Water(
          waterGeometry,
          {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load('textures/waternormals.jpg', function ( texture ) {
              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            }),
            alpha: 1.0,
            sunDirection: new THREE.Vector3(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 0.1,
            fog: scene.fog !== undefined
          }
        );
        water.position.y = -0.1;
        water.rotation.x =- Math.PI / 2;

        scene.add(water);
        
        const waterUniforms = water.material.uniforms;
        
        return water;
    }

    function animateWater(water){
        var tween = new TWEEN.Tween(water.position)
            .to({y: 0.05}, 15000)
            // .delay (1000)
             .yoyo(true)
             .repeat(Infinity)
             .easing(TWEEN.Easing.Quadratic.InOut)
             /*.onUpdate(function () {
               
            })*/
             .start();
    }

    function placeSky(scene) {
        const sky = new Sky();
        sky.scale.setScalar(10);
        scene.add(sky);
        return sky;
    }

    function placeSun(sky,scene) {
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const sun = new THREE.Vector3();
        const theta = Math.PI * (0.49 - 0.5);
        const phi = 2 * Math.PI * (0.205 - 0.5);
       
        sun.x = Math.cos(phi);
        sun.y = Math.sin(phi) * Math.sin(theta);
        sun.z = Math.sin(phi) * Math.cos(theta);

        sky.material.uniforms['sunPosition'].value.copy(sun);
        scene.environment = pmremGenerator.fromScene(sky).texture;
        return sun;
    }

    function placeGround(zAxisDeltaMult){
        const groundGeo = new THREE.BoxGeometry( 5, 0.01, 15 );
        groundGeo.translate( 0, 0, -zAxisDeltaMult*15 );
        const groundTexture = new THREE.TextureLoader().load( 'textures/pavement.jpg' , function ( texture ) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.offset.set( 0, 0 );
            texture.repeat.set( 1, 4 );
        } );
        const groundNormalTexture = new THREE.TextureLoader().load( 'textures/pavement_n.png' , function ( texture ) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        } );
        const groundMaterial = new THREE.MeshLambertMaterial( { color: 0xbbbbbb, map:groundTexture, normalMap:groundNormalTexture, normalScale: new THREE.Vector3( 1, 4 ) } );
        const groundMesh = new THREE.Mesh( groundGeo, groundMaterial );
        groundMesh.receiveShadow = true
        scene.add( groundMesh );
    }

    function placeGrass(scene){
        let planeGeometry = new THREE.PlaneGeometry(2000, 2000);
        planeGeometry.rotateX(-Math.PI / 2);
        const planeTexture = new THREE.TextureLoader().load( 'Textures/grass.jpg' , function ( texture ) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.offset.set( 0, 0 );
            texture.repeat.set( 1000, 1000 );

        } );
        const planeNormalTexture = new THREE.TextureLoader().load( 'Textures/grass_n.png' , function ( texture ) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        } );
        const planeMaterial = new THREE.MeshLambertMaterial( { color: 0xbbbbbb, map:planeTexture, normalMap:planeNormalTexture, normalScale: new THREE.Vector3( 1000, 1000 ) } );

        const  plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.y = 0;
        plane.receiveShadow = true;
        scene.add(plane);
    }

    function placeFog(scene, mode, near = 7, far = 24, color=0x000000, expDensity = 0.12){
        if (mode == FogMode.linear) {
            const near = 7;
            const far = 24;
            scene.fog = new THREE.Fog(color, near, far);
        }
        else if (mode == FogMode.exp){
            const density = expDensity;
            scene.fog = new THREE.FogExp2(color, density);
        }
        else {
            scene.fog = null;
        }
    }
    function placeGrid(visible){
        if (grid==null){
            grid = new THREE.GridHelper(2000, 2000);
            grid.position.y = 0;
            grid.material.opacity = 0.25;
            grid.material.transparent = true;
            scene.add(grid);
        }
        grid.visible = visible;
    }

    function placeSkyBox(scene, day=SkyTime.day){
        let skyboxImage = day ? "miramar" :"galaxy";
        let folder = day ? "day" :"night";

        const materialArray = createMaterialArray(folder,skyboxImage);

        var skyboxGeo = new THREE.BoxGeometry(9, 9, 9);
        skybox = new THREE.Mesh(skyboxGeo, materialArray);

        scene.add(skybox);
    }

    function createPathStrings(folder,filename, ext) {
        const basePath = "./Textures/Skybox/"+folder+"/";
        const baseFilename = basePath + filename;
        const fileType = "."+ext;
        const sides = ["ft", "bk", "up", "dn", "rt", "lf"];
        const pathStings = sides.map(side => {
            return baseFilename + "_" + side + fileType;
        });

        return pathStings;
    }

    function createMaterialArray(folder, filename) {
        const skyboxImagepaths = createPathStrings(folder,filename,"jpg");

        if (debugMode) console.log(skyboxImagepaths)

        const materialArray = skyboxImagepaths.map(image => {
            let texture = new THREE.TextureLoader().load(image);
            return new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }); //flip normal
        });
        return materialArray;
    }

    function placeGUI(scene, renderer, camera, controls, opened = true){
        const gui = new GUI()

        const cameraFolder = gui.addFolder('Camera')
        cameraFolder.add(camera.position, 'x', 0, 50)
        cameraFolder.add(camera.position, 'y', 0, 50)
        cameraFolder.add(camera.position, 'z', 0, 50)
        cameraFolder.add(camera.rotation, 'x', -180, 180).name("RotX").step(1).onChange((value) => {camera.rotation.x = THREE.MathUtils.degToRad(value);});
        cameraFolder.add(camera.rotation, 'y', -180, 180).name("RotY").step(1).onChange((value) => {camera.rotation.y = THREE.MathUtils.degToRad(value);});
        cameraFolder.add(camera.rotation, 'z', -180, 180).name("RotZ").step(1).onChange((value) => {camera.rotation.z = THREE.MathUtils.degToRad(value);});
        if (opened) cameraFolder.open()

        const controlsFolder = gui.addFolder('Controls')
        controlsFolder.add(controls, 'keyPanSpeed', 0, 50)
        controlsFolder.add(controls, 'panSpeed', 0, 50)
        controlsFolder.add(controls, 'rotateSpeed', 0, 50)
        controlsFolder.add(controls, 'zoomSpeed', 0, 50)
        controlsFolder.add(controls, 'autoRotate')
        controlsFolder.add(controls, 'autoRotateSpeed', 0, 50)
        if (opened) controlsFolder.open()

        const sceneFolder = gui.addFolder("Scene")

        var skyTimeParams = {on: true};
        sceneFolder.add(skyTimeParams,'on').name("Day/Night").setValue(true).onChange( function() {
            skyTime = skyTime == SkyTime.day ? SkyTime.night : SkyTime.day;

            if (debugMode) console.log("clicked sky time: "+skyTime + " skyMode: "+skyMode); 

            if (skyMode == SkyMode.embedded){
                
                const text = skyTime == SkyTime.day ? "material_4_baseColor" : "material_4_baseColor_night";
                const textureName = '3D/seaport/textures/'+text+'.jpg';

                skyEmbedded.material.map = new THREE.TextureLoader().load( textureName );
                skyEmbedded.material.needsUpdate = true;

                if (debugMode) console.log("loaded sky texture: "+textureName); 

            }
            
            spotLight.visible = skyTime == SkyTime.day;

            if (skyTime == SkyTime.night){
                ambientLight.visible = true
                ambientLight.color.setHex(0x09489f);

                //turn on torchlights
                for (const torch of torchLights){
                    torch.light.visible = true;
                }

                //animate torchlights
                for (const tween of torchLightsTweens) {
                    tween.start();
                }

                torchLightEnabledParams.enabled = true
                windowsLightParams.on = true
            }
            else {
                ambientLight.color.setHex(0xffffff);
            }

            //Turn on windows lights
            if (skyTime == SkyTime.night) {
                for (var emi of emissiveMeshes){
                    emi.material.emissiveIntensity =  WINDOWS_EMISSIVE_VALUE;
                }
            }
            
            fogMode = skyTime == SkyTime.night ? FogMode.exp : FogMode.linear;

            if (fogMode == FogMode.exp) {
                scene.fog.density = 0.12;
            }

            placeFog(scene,fogMode)

        } );
        
        var windowsLightParams = {on: true};
        sceneFolder.add(windowsLightParams,'on').name("Emissive light").setValue(false).listen().onChange( function(value) {
            for (var emi of emissiveMeshes){
                emi.material.emissiveIntensity = !value ? 0 : WINDOWS_EMISSIVE_VALUE;
            }
        })

        //Grid
        var gridParams = {on: gridMode};
        sceneFolder.add(gridParams, 'on').name("Grid").setValue(gridMode).listen().onChange( function(value) {
            placeGrid(gridMode)
        })
        
        //Fog
        var fogButton = { fog:function(){ 
            let currentMode = fogMode;
            fogMode = currentMode == FogMode.none ? FogMode.linear : currentMode == FogMode.exp ? FogMode.none : FogMode.exp;
            placeFog(scene,fogMode)
        }};
        sceneFolder.add(fogButton,'fog').name("Switch Fog mode (Linear, Exp, off)");
        
        var fogColorParams = {color: "#000000"};
        sceneFolder.addColor(fogColorParams,'color').name("Fog color").onChange( function() {
             scene.fog.color.set( fogColorParams.color );
        } );
        sceneFolder.add(scene.fog, 'near', 0, 50).onChange( function(value) {
            scene.fog.near = value;
        } );
        sceneFolder.add(scene.fog, 'far', 0, 50).onChange( function(value) {
            scene.fog.far = value;
        } );
        var fogDensityParams = {density: 0.1};
        sceneFolder.add(fogDensityParams, 'density', 0, 3).name("Exp. fog density").step(0.01).onChange( function(value) {
            if (fogMode == FogMode.exp) {
                scene.fog.density = value;
            }
        } );
        sceneFolder.add(renderer.shadowMap, 'enabled').name("Shadow map")
        if (opened)  sceneFolder.open()

        //Ambient light
        const ambientLightFolder = gui.addFolder("Ambient")
        ambientLightFolder.add(ambientLight,'visible').name("Enabled");
        ambientLightFolder.add(ambientLight, 'intensity', 0, 100).name("Intensity").step(0.01)
        var ambientColorParams = {color: "#FFFFFF"};
        ambientLightFolder.addColor(ambientColorParams,'color').name("Color").onChange( function(color) {
             ambientLight.color.set( color );
        } );
        if (opened)  ambientLightFolder.open()

        //Torches
        const torchesFolder = gui.addFolder("Torches")
       
        //Torches lights
        var torchLightEnabledParams = {enabled: false};
        torchesFolder.add(torchLightEnabledParams, 'enabled').name("Enabled").listen().onChange( function(value) {
            for (const torch of torchLights){
                torch.light.visible = value;
            }
        } );

        //animation
        var torchLightAnimatedParams = {animated: true};
        torchesFolder.add(torchLightAnimatedParams, 'animated').name("Animation").onChange( function(value) {
            for (const tween of torchLightsTweens) {
                if (tween.isPlaying()) {
                    tween.pause();
                }
                else {
                    tween.start();
                }
            }
            
        } );

        var torchLightColorParams = {color: "#f4ccbd"};
        torchesFolder.addColor(torchLightColorParams,'color').name("Torches color").onChange( function(color) {
            for (const torch of torchLights){
                torch.light.color.set( color );
                torch.mesh.material.color.setHex( color );
            }
        } );
        

        var torchLightIntensityParams = {torchintensity: 4};
        torchesFolder.add(torchLightIntensityParams, 'torchintensity', 0, 100).setValue(4).name("Torches intensity").step(0.01).onChange( function(value) {
            for (const torch of torchLights){
                torch.light.intensity = value;
            }
        } );

        if (opened) torchesFolder.open();

        //Spotlight
        const lightsFolder = gui.addFolder("Spotlight")
        lightsFolder.add(spotLight,'visible').name("Enabled");
        lightsFolder.add(spotLight,'castShadow').name("Shadows");
        var lightColorParams = {color: "#d4d49c"};
        lightsFolder.addColor(lightColorParams,'color').name("Light color").onChange( function() {
             spotLight.color.set( lightColorParams.color );
        } );
        lightsFolder.add(spotLight, 'intensity', 0, 100).listen().step(0.01)
        lightsFolder.add(spotLight, 'distance', 0, 100).step(0.01)
        lightsFolder.add(spotLight, 'angle', 0, 1).step(0.1)
        lightsFolder.add(spotLight, 'penumbra', 0, 1).step(0.01)
        lightsFolder.add(spotLight.position, 'x', -100, 100).step(0.01)
        lightsFolder.add(spotLight.position, 'y', -100, 100).step(0.01)
        lightsFolder.add(spotLight.position, 'z', -100, 100).step(0.01)
        lightsFolder.add(spotLight.rotation, 'x', -180, 180).name("RotX").step(0.5).onChange((value) => {spotLight.rotation.x = THREE.MathUtils.degToRad(value);});
        lightsFolder.add(spotLight.rotation, 'y', -180, 180).name("RotY").step(0.5).onChange((value) => {spotLight.rotation.y = THREE.MathUtils.degToRad(value);});
        lightsFolder.add(spotLight.rotation, 'z', -180, 180).name("RotZ").step(0.5).onChange((value) => {spotLight.rotation.z = THREE.MathUtils.degToRad(value);});

        if (opened) lightsFolder.open()

         //sky
        const skyFolder = gui.addFolder("Sky")
        var skyButton = { sky:function(){ 
            
            const currentMode = skyMode;

            skyMode = currentMode == SkyMode.off ? SkyMode.embedded : currentMode == SkyMode.embedded ? SkyMode.custom : SkyMode.off;

            skyEmbedded.visible = skyMode == SkyMode.embedded;

            if (skybox == null){
                placeSkyBox(scene,skyTime);
            }
            
            skybox.visible = skyMode == SkyMode.custom;

            if (debugMode) console.log("clicked sky: "+skyMode); 
        }};
        skyFolder.add(skyButton,'sky').name("Mode (Off, Embedded, Custom)");
        if (opened) skyFolder.open()


        //post processing
        const fxFolder = gui.addFolder("Post processing")
        var possProcessingParams = {post: true};
        fxFolder.add(possProcessingParams,'post').name("Post processing").onChange( function(value) {
            if (postProcessing.composer==null){
                setupPostProcessing(renderer)
            }

            postProcessingMode =! postProcessingMode;

            console.log("clicked pp: "+postProcessingMode); 
        } );
       
        var possProcessingBloomParams = {on: true};
        fxFolder.add(possProcessingBloomParams,'on').name("Bloom").setValue(true).onChange( function(value) {
            enablePP(postProcessing.bloomPass,value)
        } );

        var possProcessingDOFParams = {on: false};
        fxFolder.add(possProcessingDOFParams,'on').name("DOF").setValue(false).onChange( function(value) {
            enablePP(postProcessing.bokehPass,value)
        } );
      
        //Bloom
        fxFolder.add( bloomParams, 'exposure', 0.1, 2 ).name("Bloom exp").onChange( function ( value ) {
            renderer.toneMappingExposure = Math.pow( value, 4.0 );
        } );

        fxFolder.add( bloomParams, 'bloomThreshold', 0.0, 1.0 ).name("Bloom threshold").onChange( function ( value ) {
           postProcessing.bloomPass.threshold = Number( value );

        } );

        fxFolder.add( bloomParams, 'bloomStrength', 0.0, 3.0 ).name("Bloom strength").onChange( function ( value ) {
            postProcessing.bloomPass.strength = Number( value );
        } );

        fxFolder.add( bloomParams, 'bloomRadius', 0.0, 1.0 ).name("Bloom radius").step( 0.01 ).onChange( function ( value ) {
            postProcessing.bloomPass.radius = Number( value );
        } );

        //Dof

        fxFolder.add( bokehParams, 'focus', 0.1, 3000 ).name("Bokeh focus").step( 10 ).onChange( function ( value ) {
           postProcessing.bokehPass.uniforms[ 'focus' ].value = Number( value );
        } );

        fxFolder.add( bokehParams, 'aperture', 0.0, 10.0 ).name("Bokeh aperture").step( 0.1 ).onChange( function ( value ) {
            postProcessing.bokehPass.uniforms[ 'aperture' ].value = Number( value )* 0.00001;
        } );

        fxFolder.add( bokehParams, 'maxblur', 0.0, 0.01 ).name("Bokeh maxBlur").step( 0.001 ).onChange( function ( value ) {
            postProcessing.bokehPass.uniforms[ 'maxblur' ].value = Number( value );
        } );

        if (opened) fxFolder.open()

         //Audio
        const audioFolder = gui.addFolder("Audio")
        
        let player = document.getElementById('audioPlayer');
        let playerSeagull = document.getElementById('audioSeagullPlayer');

        var audioPlayingParams = {on: true};
        audioFolder.add(audioPlayingParams,'on').listen().name("Audio").setValue(true).onChange( function() {
            player.paused ? player.play() : player.pause();
            playerSeagull.paused ? playerSeagull.play() : playerSeagull.pause();
        } );
        var audioVolumeParams = {volume: player.volume};
        audioFolder.add(player, 'volume', 0, 1).name("Volume").setValue(0.05).step(0.001).onChange( function(value) {
            player.volume = value;
            playerSeagull.volume = player.volume;

        } );
        if (opened) audioFolder.open()

    }

    function setupPostProcessing(renderer){

        composer = new EffectComposer( renderer );
        postProcessing.composer = composer;

        const renderPass = new RenderPass( scene, camera );
    
        const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
        bloomPass.threshold = bloomParams.bloomThreshold;
        bloomPass.strength = bloomParams.bloomStrength;
        bloomPass.radius = bloomParams.bloomRadius;
        postProcessing.bloomPass = bloomPass;

        const bokehPass = new BokehPass(scene, camera, {
            focus: bokehParams.focus,
            aperture: bokehParams.aperture,
            maxblur: bokehParams.maxblur,
            width: bokehParams.width,
            height: bokehParams.height
        });

        bokehPass.renderToScreen = true;
        bokehPass.enabled = false
        postProcessing.bokehPass = bokehPass;

        composer.addPass( renderPass );
        composer.addPass( bloomPass );
        composer.addPass( bokehPass );

    }

    function enablePP(pass, status){
        pass.enabled = status
    }

    function placeTorchLight(father, visible = false, animate = false, deltaZ = 2, useMesh = true, addToTorchLights = true){

        if (debugMode){
            console.log("Placing torch light as child of: "+father.name);
        }

        const light = new THREE.PointLight( 0xf4ccbd, 2, 4 );
        light.visible = visible;

        var mesh;

        if (useMesh){
            const sphere = new THREE.SphereGeometry( 3, 4, 2 );
            sphere.visible = true;

            var material = new THREE.ShaderMaterial({
            uniforms: {
                color1: {value: new THREE.Color("red")},
                color2: {value: new THREE.Color("orange") },
            },
            vertexShader: `
                varying vec2 vUv;

                void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
            
                varying vec2 vUv;
                
                void main() {
                
                gl_FragColor = vec4(mix(color1, color2, vUv.y), 1.0);
                }
            `,
                wireframe: false
            });
            //new THREE.MeshBasicMaterial( { color: 0xf4ccbd } )
            mesh = new THREE.Mesh( sphere, material);

            light.add(mesh);

            animateTorchLight(light,mesh, animate);
        }
        else {
            animateTorchLight(light,null, animate);
        }

        father.add( light );
        
        light.position.z+=deltaZ;

        if (useMesh && addToTorchLights) torchLights.push({light:light,mesh:mesh});

        father.callback = function() { 
            light.visible = !light.visible
            console.log( this.name ); 
        }
    }

    function randomNumber(min, max) {
        return Math.random() * (max - min) + min;
    }
    
    document.addEventListener('click', musicPlay);
    function musicPlay() {
        document.getElementById('audioPlayer').play();
        document.getElementById('audioPlayer').volume = 0.05;

        document.getElementById('audioSeagullPlayer').play();
        document.getElementById('audioSeagullPlayer').volume = 0.05;

        document.removeEventListener('click', musicPlay);

        window.addEventListener('click', onDocumentMouseDown, false);
    }

   
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    function onDocumentMouseDown( event ) {
        event.preventDefault();
       
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
       
        raycaster.setFromCamera( mouse, camera );
       
        if (debugMode){
            console.log(scene.children);
        }

        const intersects = raycaster.intersectObjects( scene.children );
       
        if ( intersects.length > 0 ) {
            if (debugMode && intersects[0].object.name != null){
                console.log("Clicked on: "+intersects[0].object.name);
            }
            if (typeof(intersects[0].object.callback) == 'function'){
                intersects[0].object.callback();
            }
        }
    }

    window.addEventListener( 'resize', onWindowResize );
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

</script> 
<audio id="audioPlayer" autoplay loop>
    <source src="/audio/sea.ogg" type="audio/ogg">
    <embed src="/audio/sea.mp3" autostart="true" loop="true" hidden="true"> 
</audio>

<audio id="audioSeagullPlayer" autoplay loop>
    <source src="/audio/seagull.ogg" type="audio/ogg">
    <embed src="/audio/seagull.mp3" autostart="true" loop="true" hidden="true"> 
</audio>
</body>
</html>