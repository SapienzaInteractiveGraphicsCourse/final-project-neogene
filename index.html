<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andrea Leganza - 788513</title>
    <script src="js/tween/tween.umd.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./final-project-neogene/js/three/three.module.js",
                "three/addons/": "./final-project-neogene/js/three/examples/jsm/",
                "three/post/": "./final-project-neogene/js/three/examples/js/postProcessing/",
                "GUI": "./final-project-neogene/Libs/datgui/dat.gui.module.js",
                "OrbitControls": ./final-project-neogene/js/three/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <style>
        body {
            background-color: black;   
        }
    </style>
</head>
<body>

<script type="module">

    import * as THREE from 'three';
    import Stats from './final-project-neogene/js/three/examples/jsm/libs/stats.module.js';
    import { GLTFLoader } from './final-project-neogene/three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'OrbitControls';
    import { GUI } from 'GUI'

    import { EffectComposer } from  './final-project-neogene/js/three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from      './final-project-neogene/js/three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from './final-project-neogene/js/three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { Water } from           './final-project-neogene/js/three/examples/jsm/objects/Water.js';
    import { Sky } from             './final-project-neogene/js/three/examples/jsm/objects/Sky.js';

    const FogMode = {
        none : 0,
        linear : 1,
        exp : 2
    }

    const AntialiasMode = {
        off : false,
        on : true
    }

    const ShadowMode = {
        off : false,
        on : true
    }

    const SkyMode = {
        off : 0,
        embedded : 1,
    }

    const SkyTime = {
        day : true,
        night: false
    }

    const DebugMode = {
        off : false,
        on  : true
    }

    const GUIMode = {
        off : false,
        on  : true
    }

    const PostProcessingMode = {
        off : false,
        on  : true
    }

    const NightMode = {
        off : false,
        on  : true
    }

    const BoostEmissionLightMode = {
        off : false,
        on  : true
    }

    const SceneMode = {
        off : false,
        on  : true
    }

    const WaterMode = {
        off : false,
        on  : true
    }

    const ParticleMode = {
        off : false,
        on: true
    }

    const FloatingMode = {
        off : false,
        on: true
    }

    const ClickgMode = {
        off : false,
        on: true
    }

    var clock = new THREE.Clock();
    var deltaTime;

    //Settings
    var debugMode = DebugMode.off
    var debugModePhoenixPath = DebugMode.off
    var nightMode = NightMode.on
    var fogMode = FogMode.linear
    var antialiasMode = AntialiasMode.off
    var shadowsMode = ShadowMode.on
    var lightsShadow = ShadowMode.on
    var skyMode = SkyMode.embedded
    var gui = GUIMode.on
    var postProcessingMode = PostProcessingMode.off;
    var skyTime = SkyTime.day; 
    var boostEmissionLightMode = BoostEmissionLightMode.off;
    var sceneMode = SceneMode.on
    var waterMode = WaterMode.off;
    var particleMode = ParticleMode.off;
    var floatingMode = FloatingMode.on;
    var clickMode = ClickgMode.on;

    var loading = true

    var castle = [];
    var skybox;
    var skyEmbedded;
    var sea;

    var floatingTarget;
    
    var sky;
    var sun;
    var water;
    var waterUniforms;
    var liquidTween;

    var phoenix
    var phoenixTweens = [];
    var phoenixGroup;

    var crab
    var crabTweens = [];
    var crabGroup;
    
    var floatingObjects = [];

    //Ligths
    var ambientLight;
    var spotLight;
    const torchLights = []
    const torchLightsTweens = []

    //Self emitting light meshes
    const emissiveMeshes = []

    var particlesEffects = []
    var particleMaterials = []
    var particleParameters = []

    //Post processing
    const bloomParams = {
        exposure: 1,
        bloomStrength: 0.4,
        bloomThreshold: 0,
        bloomRadius: 0
    };

    const bokehParams = {
        focus : 170,
        aperture : 1.5,
        maxblur : 0.01,
        width : window.innerWidth,
        height : window.innerHeight
    }

    var composer;
    const postProcessing = {};

    const WINDOWS_EMISSIVE_VALUE = 100;
    const PHOENIX_EMISSIVE_VALUE = 0.1;

    var renderer;
    var scene;
    var camera;
    var controls;
    var stats;

    //Boat
    var boatGroup;

//SUPPORT FUNCTIONS

    function loadEnvironment(){
        const loader = new GLTFLoader();

        loader.load( '3D/seaport/scene.gltf', function ( gltf ) {
            gltf.scene.scale.set(0.01, 0.01, 0.01);

            var addToPhysicEngine = [];

            gltf.scene.traverse((o) => {
                                
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;
                    o.matrixAutoUpdate = false

                    if (debugMode){
                        console.log("Loading mesh: "+o.name);
                    }
                    if (o.name.toLowerCase() == "sky"){

                        o.castShadow = false;
                        o.receiveShadow = false;

                        skyEmbedded = o;

                        const text = skyTime == SkyTime.day ? "material_4_baseColor" : "material_4_baseColor_night";
                        const textureName = '3D/seaport/textures/'+text+'.jpg';

                        skyEmbedded.material.map = new THREE.TextureLoader().load( textureName , function  (texture) {
                            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        });
                        skyEmbedded.material.needsUpdate = true;
                        skyEmbedded.visible = skyMode == SkyMode.embedded;
                    }
                    else if (o.name.toLowerCase() == "environment"){
                        const groundNormalTexture = new THREE.TextureLoader().load( '3D/seaport/textures/Environment_normal.jpg' , function ( texture ) {
                            o.material.normalMap = texture
                            o.material.normalScale = new THREE.Vector3( 0.2, 0.2 );
                            o.material.transparent = false
                            o.material.needsUpdate = true;

                        });

                        castle.push(o);
                    }
                    else if (o.name.toLowerCase() == "sea"){
                        o.matrixAutoUpdate = true
                        o.castShadow = false;
                        o.receiveShadow = false;
                        floatingTarget = waterMode ? water : o
                        sea = o;
                        animateLiquid(o)
                    }
                    else if (o.name.toLowerCase() == "sand"){
                        o.castShadow = false;
                        o.receiveShadow = true;
                        o.material.transparent = false
                    }
                    else if (o.name.toLowerCase() == "base"){
                        castle.push(o);
                        o.material.transparent = false
                    }
                    else if (o.name.toLowerCase().includes("fortress")){
                        o.material.transparent = false
                        castle.push(o);
                    }
                    else if (o.name.toLowerCase().includes("barrel")){
                        o.material.transparent = false
                        castle.push(o);
                    }
                    else if (o.name.toLowerCase().includes("torch")){
                        o.matrixAutoUpdate = true
                        placeTorchLight(o);
                        castle.push(o);
                    }

                    if (o.material.emissiveMap!=null && o.name == "Tower") {
                        if (debugMode){
                            console.log("Fixing emissive for: "+o.name);
                        }

                        o.material.transparent = false

                        castle.push(o);

                        if (boostEmissionLightMode == BoostEmissionLightMode.on){
                            o.material.emissiveIntensity = WINDOWS_EMISSIVE_VALUE; //increase windows lights
                        }

                       emissiveMeshes.push (o);

                    }
                    //if required
                    //o.material.normalScale.y *= -1;
                }
            });

            if (sceneMode == SceneMode.on){
                scene.add( gltf.scene );
            }

            loadPhoenix()


        }, undefined, function ( error ) {

            console.error( error );

        } );
    }

//BOAT

    function removeBoat(){
        if (boatGroup!=null){
            boatGroup.visible = false
            //scene.remove(boatGroup.children)
            //boatGroup.parent.remove(boatGroup);
            //boatGroup = null
        }
    }

    function loadBoat(target){

        if (boatGroup!=null){
            boatGroup.visible = true
            return
        }

        const loader = new GLTFLoader();

        loader.load( '3D/boat/boat.gltf', function ( gltf ) {

            gltf.scene.scale.set(0.1, 0.1, 0.1);
            gltf.scene.position.set(5,0,-0.1);
           
            gltf.scene.traverse((o) => {
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;

                    if (o.name.toLowerCase().includes("torch")){
                        placeTorchLight(o, true, 4, 1, false, 0, false, 1, false); //parent, intensity, decay, animate, deltaZ, addmesh,  distance, addtotorches
                        oscillateBoatTorch(o);
                    }
                    else if (o.name == "Body"){
                        const groundNormalTexture = new THREE.TextureLoader().load( '3D/boat/textures/Image-Image_n.jpg' , function ( texture ) {
                            o.material.normalMap = texture
                            o.material.normalScale = new THREE.Vector3( 1, 1 );

                            if (debugMode){
                                console.log("Applying normal map to: "+o.name);
                            }
                        });
                    }
                    else if (o.name == "Hull"){
                        const groundNormalTexture = new THREE.TextureLoader().load( '3D/boat/textures/Image_n.jpg' , function ( texture ) {
                            o.material.normalMap = texture
                            o.material.normalScale = new THREE.Vector3( 1, 1 );

                            if (debugMode){
                                console.log("Applying normal map to: "+o.name);
                            }
                        });
                    }

                    if (o.material.emissiveMap!=null) {
                        if (debugMode){
                            console.log("Fixing emissive for: "+o.name);
                        }

                        if (boostEmissionLightMode == BoostEmissionLightMode.on){
                            o.material.emissiveIntensity = WINDOWS_EMISSIVE_VALUE; //increase windows lights
                        }
                        emissiveMeshes.push (o);
                    }
                }
            }
            )
            
            boatGroup = new THREE.Group();
            boatGroup.position.z = 0;
            boatGroup.rotation.y = Math.PI*3/2;

            if (target == water) {
                boatGroup.rotation.x = Math.PI / 2;
                target.add( boatGroup );
            }
            else if (target == sea){
                boatGroup.rotation.y = Math.PI / 2;
                gltf.scene.rotation.y = THREE.MathUtils.degToRad(-130);
                gltf.scene.position.set(-300,-15,300);
                gltf.scene.scale.set(10, 10, 10);
                target.add( boatGroup );
            }
            else if (target == null){
                scene.add( boatGroup );
            }

            boatGroup.add( gltf.scene );

            if (debugMode){
                console.log("Loading boatGroup: "+boatGroup.position);
            }

        })

    }

    function endLoadingMeshes(){

        placeFloatingObjects(floatingTarget);

        if (particleMode){
            placeFireFlies()
        }
        
        //Post processing
        if (postProcessingMode){
            setupPostProcessing(renderer);
        }

        //GUI
        if (gui){
            placeGUI(scene, renderer, camera, controls, false);
        }

        loading = false;
        
        //we can now start the whole engine
        animate();
    }

    //PHOENIX

    function removePhoenix(){
        if (phoenixGroup!=null){

            phoenixGroup.visible = false

            for (let tween of phoenixTweens){
                tween.stop()
            }
            
            /*phoenixGroup.parent.remove(phoenixGroup)
            
            if (phoenix!=null){
                phoenix.parent.remove(phoenix)
                phoenix = null
            }
            phoenixGroup = null
            
            removePhoenixPath()

            for (let tween of phoenixTweens){
                tween.stop()
                TWEEN.remove(tween)
            }

            phoenixTweens = []
            */
        }
    }

    function loadPhoenix(firstLoad = true){

        if (phoenix!=null || phoenixGroup!=null){
            phoenixGroup.visible = true

            for (let tween of phoenixTweens){
                tween.start()
            }
            return
        }

        const loader = new GLTFLoader();

        loader.load( '3D/phoenix/phoenix.gltf', function ( gltf ) {
            gltf.scene.position.set(0,1,5);
            //gltf.scene.rotation.set(0,-Math.PI/2,0);
            gltf.scene.traverse((o) => {
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;

                    if (debugMode){
                        console.log("Loading mesh: "+o.name + " data (axis: "+o.userData.axis+" prop: "+o.userData.prop+")");
                    }

                    if (o.userData.axis!=null && o.userData.prop!=0){
                        animatePhoenixMesh(o,o.userData.axis,o.userData.prop, o.userData.delay, o.userData.easing)
                    }

                    if (o.material.emissiveMap!=null) {
                        if (debugMode){
                            console.log("Boosting emissive for: "+o.name);
                        }

                        if (boostEmissionLightMode == BoostEmissionLightMode.on){
                            o.material.emissiveIntensity = PHOENIX_EMISSIVE_VALUE; //increase phoenix 
                        }
                        emissiveMeshes.push (o);
                    }
                }
            }
            )
            
            phoenix = gltf.scene.getObjectByName("Body");

            phoenixGroup = new THREE.Group();
            phoenixGroup.add( gltf.scene );
            
            scene.add( phoenixGroup );

            loadPhoenixPath();
            
            if (firstLoad){
                endLoadingMeshes();
            }
        })
    }

//Crab
    function remoteCrab(){
        if (crabGroup!=null){
            //scene.remove(crabGroup.children)
            //crabGroup.parent.remove(crabGroup);
            //crabGroup = null
            crabGroup.visible = false

            for (let tween of crabTweens){
                tween.stop()
            }
            
        }
    }

    function loadCrab(){

        if (crab!=null || crabGroup!=null){
            crabGroup.visible = true

            for (let tween of crabTweens){
                tween.start()
            }

            return
        }

        const loader = new GLTFLoader();

        loader.load( '3D/crab/crab.gltf', function ( gltf ) {
            gltf.scene.position.set(-0.3,0.25,1.5);
            gltf.scene.rotation.set(0,-Math.PI/4,0);
            gltf.scene.traverse((o) => {
                if (o.isMesh) {
                    o.castShadow = false;
                    o.receiveShadow = false;

                    if (debugMode){
                        console.log("Loading mesh: "+o.name + " data (axis: "+o.userData.axis+" prop: "+o.userData.prop+")");
                    }

                    if (o.userData.axis!=null && o.userData.prop!=0){
                        animateCrabMesh(o,o.userData.axis,o.userData.prop, o.userData.delay, o.userData.easing, o.userData.speed != null ? o.userData.speed : 1)
                    }

                    if (o.name.toLowerCase().includes("eye")){
                       
                    }
                }
            }
            )
            
            crab = gltf.scene.getObjectByName("Crab");

            animateCrabBodyMesh(crab)

            crabGroup = new THREE.Group();
            crabGroup.add( gltf.scene );
            crab.lookAt(camera.position)
            scene.add( crabGroup );
        })
    }

    var tangent = new THREE.Vector3();
    var axis = new THREE.Vector3();
    var up = new THREE.Vector3( 1, 0, 0 )
    var counter = 0;
    var spline;

    function removePhoenixPath(){
        if (spline!=null){
            scene.remove(spline)
            spline = null
            counter = 0
        }
    }

    function loadPhoenixPath(){

        if (debugMode){
            console.log("Loading phoenix path");
        }

        spline = new THREE.CatmullRomCurve3( [
        new THREE.Vector3( -1 , 1, -1),
        new THREE.Vector3( -1.2 , 1, 1.1),
        new THREE.Vector3( 0.8 , 1, 1),
        new THREE.Vector3( 1 , 1, -1.1),
    ] , true );

        if (debugModePhoenixPath){
            const points = spline.getPoints( 30 );
            const geometry = new THREE.BufferGeometry().setFromPoints( points );

            const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

            // Create the final object to add to the scene
            const splineObject = new THREE.Line( geometry, material );
        // splineObject.rotation.x = Math.PI*0.5

            scene.add(splineObject)
        }
    }

    function animatePhoenixMesh(mesh, axis, delta, delay, easing){

        if (debugMode){
            console.log("Animating phoenix: "+mesh.name);
        }

        const tween = new TWEEN.Tween(mesh.rotation)
            .to({[axis]:mesh.rotation[axis] + 0.2*delta},1000)
            .yoyo(true)
            .delay(delay != null ? delay*1000 : 0)
            .repeat(Infinity)
            .easing(easing != null ? (easing == 1 ? TWEEN.Easing.Linear.None : TWEEN.Easing.Quadratic.InOut) : TWEEN.Easing.Linear.None)
            /*.onUpdate(function () {
              
            })*/
            
            .start()

        phoenixTweens.push(tween)
    
    }

function animateCrabMesh(mesh, axis, delta, delay, easing, speed = 1){

if (debugMode){
    console.log("Animating crab: "+mesh.name);
}

const tween = new TWEEN.Tween(mesh.rotation)
    .to({[axis]:mesh.rotation[axis] + 0.2*delta},1000*speed)
    .yoyo(true)
    .delay(delay != null ? delay*1000 : 0)
    .repeat(Infinity)
    .easing(easing != null ? (easing == 1 ? TWEEN.Easing.Linear.None : TWEEN.Easing.Quadratic.InOut) : TWEEN.Easing.Linear.None)
    /*.onUpdate(function () {
      
    })*/
    .start()

    crabTweens.push(tween)

}

function animateCrabBodyMesh(mesh){

if (debugMode){
    console.log("Animating crab: "+mesh.name);
}

const tween = new TWEEN.Tween(mesh.position)
    .to({x:mesh.position.x + 0.2},1000)
    .yoyo(true)
    .repeat(Infinity)
    .easing(TWEEN.Easing.Linear.None)
    /*.onUpdate(function () {
      
    })*/
    .start()

    crabTweens.push(tween)

}

    function movePhoenixAroundPath(delta) {
        if (counter <= 1) {
            const p = spline.getPointAt(counter);

            phoenixGroup.position.set(p.x,p.y,p.z);
            
            tangent = spline.getTangentAt(counter).normalize();

            axis.crossVectors( up, tangent ).normalize();

            var radians = Math.acos( up.dot( tangent ) );

            phoenixGroup.quaternion.setFromAxisAngle( axis, radians );

            counter += delta
        } else {
            counter = 0;
        }
    }

//Torch lights
    function animateTorchLight(light, mesh, autoStart = false){
        if (debugMode){
            console.log("Animating torch light: "+light.parent);
        }
        const tween = new TWEEN.Tween(light)
            .to({intensity: 0}, ( Math.random()) * 3000 + 1000)
            .yoyo(true)
            .repeat(Infinity)
            .easing(TWEEN.Easing.Circular.InOut);
            
            if (autoStart) tween.start();

            torchLightsTweens.push(tween)
    }
//Boat
    function oscillateBoatTorch(mesh){
        if (debugMode){
            console.log("Oscillating mesh: "+mesh.name);
        }
        
        const tween = new TWEEN.Tween(mesh.rotation)
            .to({x:mesh.rotation.x + Math.PI / 5},4000)
            .yoyo(true)
            .repeat(Infinity)
            .easing(TWEEN.Easing.Quadratic.InOut)
            /*.onUpdate(function () {
              
            })*/
            .start()
    }

    function removeFloatingObjects(){

        if (floatingObjects.length>0){
            
            for (const fl of floatingObjects ){
                fl.visible = true
            }

            return
        }

        floatingObjects.forEach(floating => {
            floating.parent.remove(floating)
        })

        floatingObjects = []
    }

    function placeFloatingObjects(target){

        if (floatingObjects.length>0){
            for (const fl of floatingObjects ){
                fl.visible = false
            }
            return
        }

        const geometry = new THREE.PlaneGeometry( 1, 1 );
        const material = new THREE.MeshBasicMaterial( {color: 0x263529, side: THREE.DoubleSide,depthWrite: false, depthTest: true, transparent: true} );

        const textureName = 'Textures/leaf'+(Math.floor(Math.random() * 3) + 0)+'.png';

        material.map = new THREE.TextureLoader().load( textureName , function  (texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        });
        
        var leavesCoordPosition = [];

        for (var i= 0; i <20; i++){
            var ranXNum = Math.ceil(Math.random() * 7) * (Math.round(Math.random()) ? 1 : -1)
            var ranYNum = Math.ceil(Math.random() * 7) * (Math.round(Math.random()) ? 1 : -1)

            const pos = new THREE.Vector3(ranXNum,0.01,ranYNum)
            leavesCoordPosition.push(pos);     
        }
    
        leavesCoordPosition.forEach(position => {

            if (debugMode){
                console.log(position);
            }
       
            const mesh = new THREE.Mesh( geometry, material );

            mesh.rotation.z =  Math.random() * Math.PI * 2; 

            mesh.rotation.x = target == water ? 0 : Math.PI/2;
            
            mesh.position.set(  position.x*(target == water ? 1 : 100),
                                position.y,
                                position.z*(target == water ? 1 : 100));
            
            let s = Math.random() *(target == water ? 0.1 : 30) + 0.1;
            mesh.scale.set(s, s, s);
            mesh.userData.delta = Math.random() * Math.PI * 2;

            floatingObjects.push(mesh);
        
            target.add(mesh);
        });

    }

    function placeWater(scene, sun) {
        const waterGeometry = new THREE.PlaneGeometry(20, 20);
        const water = new Water(
          waterGeometry,
          {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load('textures/waternormals.jpg', function ( texture ) {
              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            }),
            alpha: 1.0,
            sunDirection: sun.position,
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 0.1,
            fog: scene.fog !== undefined
          }
        );
        water.receiveShadow = true
        water.position.y = -0.1;
        water.rotation.x =- Math.PI / 2;

        scene.add(water);
        
        waterUniforms = water.material.uniforms;
        
        return water;
    }


    function animateLiquid(target){

        if (liquidTween!=null){
            TWEEN.remove(liquidTween)
            liquidTween = null
        }

        if (debugMode){
            console.log("Animating water: "+target.name)
        }
        target.position.y = target == water ? -0.1 : 0;

        liquidTween = new TWEEN.Tween(target.position)
            .to({x: 0, 
                 y : target == water ? 0 : 20, 
                 z : 0},
            10000)
            // .delay (1000)
             .yoyo(true)
             .repeat(Infinity)
             .easing(TWEEN.Easing.Quadratic.InOut)
             /*.onUpdate(function () {
               
            })*/
             .start();
    }

    function placeSky(scene) {
        const sky = new Sky();
        sky.scale.setScalar(10);
        scene.add(sky);
        return sky;
    }

    function placeSun(sky,scene) {
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const sun = new THREE.Vector3();
        const theta = Math.PI * (0.49 - 0.5);
        const phi = 2 * Math.PI * (0.205 - 0.5);
       
        sun.x = Math.cos(phi);
        sun.y = Math.sin(phi) * Math.sin(theta);
        sun.z = Math.sin(phi) * Math.cos(theta);

        sky.material.uniforms['sunPosition'].value.copy(sun);
        scene.environment = pmremGenerator.fromScene(sky).texture;
        return sun;
    }

    function placeFog(scene, mode, near = 7, far = 24, color=0x000000, expDensity = 0.12){

        if (debugMode){
            console.log(mode)
        }

        if (mode == FogMode.linear) {
            const near = 7;
            const far = 24;
            scene.fog = new THREE.Fog(color, near, far);
        }
        else if (mode == FogMode.exp){
            const density = expDensity;
            scene.fog = new THREE.FogExp2(color, density);
        }
        else {
            scene.fog = null;
        }
    }

    //GUI
    function placeGUI(scene, renderer, camera, controls, opened = true){
        const gui = new GUI()

        const cameraFolder = gui.addFolder('Camera')
        cameraFolder.add(camera.position, 'x', 0, 50)
        cameraFolder.add(camera.position, 'y', 0, 50)
        cameraFolder.add(camera.position, 'z', 0, 50)
        cameraFolder.add(camera.rotation, 'x', -180, 180).name("RotX").step(1).onChange((value) => {camera.rotation.x = THREE.MathUtils.degToRad(value);});
        cameraFolder.add(camera.rotation, 'y', -180, 180).name("RotY").step(1).onChange((value) => {camera.rotation.y = THREE.MathUtils.degToRad(value);});
        cameraFolder.add(camera.rotation, 'z', -180, 180).name("RotZ").step(1).onChange((value) => {camera.rotation.z = THREE.MathUtils.degToRad(value);});
        if (opened) cameraFolder.open()

    //Controls
        const controlsFolder = gui.addFolder('Controls')
        controlsFolder.add(controls, 'keyPanSpeed', 0, 50)
        controlsFolder.add(controls, 'panSpeed', 0, 50)
        controlsFolder.add(controls, 'rotateSpeed', 0, 50)
        controlsFolder.add(controls, 'zoomSpeed', 0, 50)
        controlsFolder.add(controls, 'autoRotate')
        controlsFolder.add(controls, 'autoRotateSpeed', 0, 50)
        if (opened) controlsFolder.open()

    //Scene
        const sceneFolder = gui.addFolder("Scene")

        var skyTimeParams = {on: true};
        sceneFolder.add(skyTimeParams,'on').name("Day/Night").setValue(true).onChange( function() {
            skyTime = skyTime == SkyTime.day ? SkyTime.night : SkyTime.day;

            if (debugMode) console.log("clicked sky time: "+skyTime + " skyMode: "+skyMode); 

            if (skyMode == SkyMode.embedded){
                
                const text = skyTime == SkyTime.day ? "material_4_baseColor" : "material_4_baseColor_night";
                const textureName = '3D/seaport/textures/'+text+'.jpg';

                skyEmbedded.material.map = new THREE.TextureLoader().load( textureName , function  (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

                    if (skyTime == SkyTime.night){
                        skyEmbedded.material.emissiveMap = texture;
                        skyEmbedded.material.emissiveIntensity = 100
                        skyEmbedded.material.emissive = new THREE.Color("white")
                    }
                    else {
                        skyEmbedded.material.emissiveMap = null
                        skyEmbedded.material.emissiveIntensity = 0
                        skyEmbedded.material.emissive = new THREE.Color("black")
                    }

                    skyEmbedded.material.needsUpdate = true;
                });

                if (debugMode) console.log("loaded sky texture: "+textureName); 

            }

            let playerSeagull = document.getElementById('audioSeagullPlayer');
            let playerCrickets = document.getElementById('audioCricketsPlayer');
            
            if (skyTime == SkyTime.night){
                ambientLight.visible = true
                ambientLight.color.setHex(0x09489f);

                //turn on torchlights
                for (const torch of torchLights){
                    torch.light.visible = true;
                }

                //animate torchlights
                for (const tween of torchLightsTweens) {
                    tween.start();
                }

                torchLightEnabledParams.enabled = true
                windowsLightParams.on = true

                //Turn on windows lights
                for (var emi of emissiveMeshes){
                    emi.material.emissiveIntensity =  WINDOWS_EMISSIVE_VALUE;
                }

                spotLight.intensity = 50
                spotLight.penumbra = 0.2
                spotLight.color.setHex(0x6888d9)


                removePhoenix()

                placeFireFlies()

                loadBoat(floatingTarget)
                loadCrab()

                playerCrickets.play()
                playerSeagull.pause()
                playerSeagull.currentTime = 0

                renderer.toneMappingExposure = Math.pow( 1, 4.0 );

            }
            else { //day
                spotLight.intensity = waterMode ? 20 : 15
                spotLight.distance = 5
                spotLight.penumbra = 0.05

                spotLight.color.setHex(0xffffff)
                ambientLight.color.setHex(0xffffff);

                 //turn on torchlights
                for (const torch of torchLights){
                    torch.light.visible = false;
                }

                //animate torchlights
                for (const tween of torchLightsTweens) {
                    tween.pause();
                }

                torchLightEnabledParams.enabled = false
                windowsLightParams.on = false

                removeFireFlies()

                removeBoat()

                remoteCrab()

                loadPhoenix(false)

                playerCrickets.pause()
                playerCrickets.currentTime = 0
                playerSeagull.play()

                renderer.toneMappingExposure = Math.pow( 0.9, 4.0 );

            }
            
            fogMode = skyTime == SkyTime.night ? FogMode.exp : FogMode.linear;

            if (fogMode == FogMode.exp) {
                scene.fog.density = 0.12;
            }

            placeFog(scene,fogMode)

        } );
        
        var windowsLightParams = {on: true};
        sceneFolder.add(windowsLightParams,'on').name("Emissive light").setValue(false).listen().onChange( function(value) {
            for (var emi of emissiveMeshes){
                emi.material.emissiveIntensity = !value ? 0 : WINDOWS_EMISSIVE_VALUE;
            }
        })

    //Fog
        var fogButton = { fog:function(){ 
            let currentMode = fogMode;
            fogMode = currentMode == FogMode.none ? FogMode.linear : currentMode == FogMode.exp ? FogMode.none : FogMode.exp;
            placeFog(scene,fogMode)
        }};
        sceneFolder.add(fogButton,'fog').name("Switch Fog mode (Linear, Exp, off)")
        
        var fogColorParams = {color: "#000000"};
        sceneFolder.addColor(fogColorParams,'color').name("Fog color").onChange( function() {
             scene.fog.color.set( fogColorParams.color );
        } );
        sceneFolder.add(scene.fog, 'near', 0, 50).name("Linear fog near").onChange( function(value) {
            if (fogMode == FogMode.linear){
                scene.fog.near = value;
            }
        } );
        sceneFolder.add(scene.fog, 'far', 0, 50).name("Linear fog far").onChange( function(value) {
            if (fogMode == FogMode.linear){
                scene.fog.far = value;
            }
        } );
        var fogDensityParams = {density: 0.1};
        sceneFolder.add(fogDensityParams, 'density', 0, 3).name("Exp. fog density").step(0.01).onChange( function(value) {
            if (fogMode == FogMode.exp) {
                scene.fog.density = value;
            }
        } );
        sceneFolder.add(renderer.shadowMap, 'enabled').name("Shadow map")
        
        var envParams = {on: true};
        sceneFolder.add(envParams, 'on',).name("Buildings").onChange( function(value) {
           castle.forEach(piece => {
            piece.visible = value;
           }
        )});

        var floatingParams = {on: floatingMode};
        sceneFolder.add(floatingParams, 'on',).name("Leaves").onChange( function(value) {
            floatingMode = value

            floatingMode ? placeFloatingObjects(floatingTarget) : removeFloatingObjects()
        });

        var boatParams = {on: true};
        sceneFolder.add(boatParams, 'on',).name("Boat").onChange( function(value) {
            value ? loadBoat(floatingTarget):removeBoat();
        });

        var phoenixParams = {on: true};
        sceneFolder.add(phoenixParams, 'on',).name("Phoenix").onChange( function(value) {
            value ? loadPhoenix(false) : removePhoenix();
        });
        
        if (true)  sceneFolder.open()

    //Ambient light
        const ambientLightFolder = gui.addFolder("Ambient light")
        ambientLightFolder.add(ambientLight,'visible').listen().name("Enabled");
        ambientLightFolder.add(ambientLight, 'intensity', 0, 100).name("Intensity").step(0.01)
        var ambientColorParams = {color: "#FFFFFF"};
        ambientLightFolder.addColor(ambientColorParams,'color').name("Color").onChange( function(color) {
             ambientLight.color.set( color );
        } );
        if (opened)  ambientLightFolder.open()

    //Torches
        const torchesFolder = gui.addFolder("Torches")
       
        //Torches lights
        var torchLightEnabledParams = {enabled: false};
        torchesFolder.add(torchLightEnabledParams, 'enabled').name("Enabled").listen().onChange( function(value) {
            for (const torch of torchLights){
                torch.light.visible = value;
            }
        } );

        //animation
        var torchLightAnimatedParams = {animated: true};
        torchesFolder.add(torchLightAnimatedParams, 'animated').name("Animation").onChange( function(value) {
            for (const tween of torchLightsTweens) {
                if (tween.isPlaying()) {
                    tween.pause();
                }
                else {
                    tween.start();
                }
            }
            
        } );

        var torchLightColorParams = {color: "#f4ccbd"};
        torchesFolder.addColor(torchLightColorParams,'color').name("Torches color").onChange( function(color) {
            for (const torch of torchLights){
                torch.light.color.set( color );
                torch.mesh.material.color.setHex( color );
            }
        } );
        

        var torchLightIntensityParams = {torchintensity: 4};
        torchesFolder.add(torchLightIntensityParams, 'torchintensity', 0, 100).setValue(4).name("Torches intensity").step(0.01).onChange( function(value) {
            for (const torch of torchLights){
                torch.light.intensity = value;
            }
        } );

        if (true) torchesFolder.open();

        //Spotlight
        const lightsFolder = gui.addFolder("Spotlight")
        lightsFolder.add(spotLight,'visible').name("Enabled");
        lightsFolder.add(spotLight,'castShadow').name("Shadows");
        var lightColorParams = {color: "#d4d49c"};
        lightsFolder.addColor(lightColorParams,'color').name("Light color").onChange( function() {
             spotLight.color.set( lightColorParams.color );
        } );
        lightsFolder.add(spotLight, 'intensity', 0, 100).listen().step(0.01)
        lightsFolder.add(spotLight, 'distance', 0, 100).step(0.01)
        lightsFolder.add(spotLight, 'angle', 0, 1).step(0.1)
        lightsFolder.add(spotLight, 'penumbra', 0, 1).step(0.01)
        lightsFolder.add(spotLight.position, 'x', -100, 100).step(0.01)
        lightsFolder.add(spotLight.position, 'y', -100, 100).step(0.01)
        lightsFolder.add(spotLight.position, 'z', -100, 100).step(0.01)
       
        if (opened) lightsFolder.open()

         //sky
        const skyFolder = gui.addFolder("Sky")
        var skyButton = { sky:function(){ 
            
            const currentMode = skyMode;

            skyMode = currentMode == SkyMode.off ? SkyMode.embedded : currentMode == SkyMode.off;

            skyEmbedded.visible = skyMode == SkyMode.embedded;
            
        }};
        skyFolder.add(skyButton,'sky').name("Mode (Embedded / Off)");
        if (opened) skyFolder.open()

        //Water
        const waterFolder = gui.addFolder("Water")
        var waterButton = { water:function(){ 
            
            waterMode = waterMode == WaterMode.on ? WaterMode.off : WaterMode.on;

            if (water==null && waterMode){
                sky = placeSky(scene);
                sun = placeSun(sky,scene);
                water = placeWater(scene, sun);
                water.name = "water"
            }
            
            if (water !=null && !waterMode){
                scene.remove(sky);
                sky = null
                scene.remove(sun);
                sun = null
                waterUniforms = []
                scene.remove(water);
                water = null
            }

            sea.visible = waterMode == false;

            floatingTarget = waterMode ? water : sea

            animateLiquid(floatingTarget)    
            
        }};
        waterFolder.add(waterButton,'water').name("Sea On / Off");

        if (opened) waterFolder.open()

         //particles
        const particlesFolder = gui.addFolder("Particles")
        var particlesParams = {on: particleMode};
        particlesFolder.add(particlesParams,'on').name("Night Fireflies").setValue(particleMode).onChange( function(value) {

            particleMode = value

            if (value){
                placeFireFlies()
            }
            else {
                removeFireFlies()
            }
        })
        if (opened) particlesFolder.open()

        //post processing
        const fxFolder = gui.addFolder("Post processing")
        var possProcessingParams = {post: postProcessingMode};
        fxFolder.add(possProcessingParams,'post').name("Post processing").setValue(postProcessingMode).onChange( function(value) {
            if (postProcessing.composer==null){
                setupPostProcessing(renderer)
            }

            postProcessingMode =! postProcessingMode;

            renderer.autoClear = !postProcessingMode

            ambientLight.intensity = postProcessingMode? 2: 2
            spotLight.intensity = postProcessingMode? 30 : 20

            console.log("clicked pp: "+postProcessingMode); 
        } );
       
        var possProcessingBloomParams = {on: true};
        fxFolder.add(possProcessingBloomParams,'on').name("Bloom").setValue(true).onChange( function(value) {
            enablePP(postProcessing.bloomPass,value)
        } );
      
        //Bloom
        fxFolder.add( bloomParams, 'exposure', 0.1, 2 ).name("Bloom exp").onChange( function ( value ) {
            renderer.toneMappingExposure = Math.pow( value, 4.0 );
        } );

        fxFolder.add( bloomParams, 'bloomThreshold', 0.0, 1.0 ).name("Bloom threshold").onChange( function ( value ) {
           postProcessing.bloomPass.threshold = Number( value );

        } );

        fxFolder.add( bloomParams, 'bloomStrength', 0.0, 3.0 ).name("Bloom strength").onChange( function ( value ) {
            postProcessing.bloomPass.strength = Number( value );
        } );

        fxFolder.add( bloomParams, 'bloomRadius', 0.0, 1.0 ).name("Bloom radius").step( 0.01 ).onChange( function ( value ) {
            postProcessing.bloomPass.radius = Number( value );
        } );

        if (opened) fxFolder.open()

         //Audio
        const audioFolder = gui.addFolder("Audio")
        
        let player = document.getElementById('audioPlayer');
        let playerSeagull = document.getElementById('audioSeagullPlayer');
        let playerCrickets = document.getElementById('audioCricketsPlayer');

        var audioPlayingParams = {on: true};
        audioFolder.add(audioPlayingParams,'on').listen().name("Audio").setValue(true).onChange( function() {
            player.paused ? player.play() : player.pause();
            
            if (skyTime == SkyTime.day) {
                playerSeagull.paused ? playerSeagull.play() : playerSeagull.pause();
            }
            else {
                playerCrickets.paused ? playerCrickets.play() : playerCrickets.pause();
            }
        } );
        var audioVolumeParams = {volume: player.volume};
        audioFolder.add(player, 'volume', 0, 1).name("Volume").setValue(0.05).step(0.001).onChange( function(value) {
            player.volume = value;
            playerSeagull.volume = player.volume;
            playerCrickets.volume = player.volume;
        } );
        if (opened) audioFolder.open()

        //Debug
        const debugFolder = gui.addFolder('Debug')
        var debugParams = {on: debugMode};
        debugFolder.add(debugParams,'on').name("Log messages").setValue(debugMode).onChange( function(value) {
            debugParams = value
        })
        if (opened) debugFolder.open()

    }

    function removeFireFlies(){
        for (var p of particlesEffects){
            scene.remove(p)
        }

        particleMaterials = []
        particlesEffects = []

        particleMode = ParticleMode.off
    }

    function placeFireFlies(){
        
        if (particlesEffects.length > 0){
            return
        }

        particleMode = ParticleMode.on

        const geometry = new THREE.BufferGeometry();
        const vertices = [];

        const textureLoader = new THREE.TextureLoader();

        const sprite = textureLoader.load( '' );

        for ( let i = 0; i < 100; i ++ ) {

            const x = Math.random() * 9 - 4.5;
            const y = Math.random() * 9 - 4.5;
            const z = Math.random() * 9 - 4.5;

            vertices.push( x, y, z );
        }

        geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

        particleParameters = [
            [[ 1.0, 1.0, 1.0 ], sprite, 0.05 ],
            [[ 0.86, 0.86, 0.67], sprite, 0.02],
            [[ 0.3, 0.3, 0.3], sprite, 0.03 ],
        ];

        for ( let i = 0; i < particleParameters.length; i ++ ) {

            const color = particleParameters[ i ][ 0 ];
            const sprite = particleParameters[ i ][ 1 ];
            const size = particleParameters[ i ][ 2 ];

            particleMaterials[ i ] = new THREE.PointsMaterial( { size: size, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );
            particleMaterials[ i ].color.setHSL( color[ 0 ], color[ 1 ], color[ 2 ] );

            const particles = new THREE.Points( geometry, particleMaterials[ i ] );

            particlesEffects.push(particles);

            scene.add( particles );
        }
    }

    function setupPostProcessing(renderer){

        composer = new EffectComposer( renderer );
        postProcessing.composer = composer;

        const renderPass = new RenderPass( scene, camera );
    
        const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
        renderer.toneMappingExposure = Math.pow( 0.9, 4.0 );
        bloomPass.threshold = bloomParams.bloomThreshold;
        bloomPass.strength = bloomParams.bloomStrength;
        bloomPass.radius = bloomParams.bloomRadius;
        postProcessing.bloomPass = bloomPass;

        composer.addPass( renderPass );
        composer.addPass( bloomPass );
    }

    function enablePP(pass, status){
        pass.enabled = status
    }

    function placeTorchLight(father, visible = false, intensity = 8, decay = 1, animate = false, deltaZ = 3, useMesh = true, distance = 0.3, addToTorchLights = true){

        if (true){
            console.log("Placing torch light as child of: "+father.name);
        }

        const light = new THREE.PointLight( 0xffffbb, intensity, decay );
        light.visible = visible 
        light.distance = distance
        father.add( light );

        if (useMesh){
            const sphere = new THREE.SphereGeometry( 3, 4, 2 );

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    u_time: { type: "f", value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    uniform float u_time;

                    void main() {
                        vUv = uv;

                        mat4 scale = mat4(vec4(1.0+sin(u_time)*0.1,0.0,0.0,0.0),
                                        vec4(0.0,1.0+sin(u_time)*0.3,0.0,0.0),
                                        vec4(0.0,0.0,1.0+sin(u_time)*0.5,0.0),
                                        vec4(0.0,0.0,0.0,1.0));
                        gl_Position = projectionMatrix * modelViewMatrix * scale * vec4(position,1.0);
                    }
                `,
                fragmentShader: `
                    uniform float u_time;
                    varying vec2 vUv;
                    
                    void main() {
                        gl_FragColor = vec4(mix(vec3(1,0,0), vec3(1,0.65,0), vUv.y+sin(u_time)), 1.0);
                    }
            `
            });

            const mesh = new THREE.Mesh( sphere, mat);
            light.add(mesh);
            animateTorchLight(light,mesh, animate);

            if (addToTorchLights) torchLights.push({light:light,mesh:mesh});

        }
        else {
            animateTorchLight(light,null, animate);
        }
        
        light.position.z+=deltaZ;

        //Used to hide the light on click o the mesh 
        father.callback = function() { 
            light.visible = !light.visible
            console.log( this.name ); 
        }
    }

    function randomNumber(min, max) {
        return Math.random() * (max - min) + min;
    }
    
    document.addEventListener('click', musicPlay);
    function musicPlay() {
        document.getElementById('audioPlayer').play();
        document.getElementById('audioPlayer').volume = 0.05;

        document.getElementById('audioSeagullPlayer').play();
        document.getElementById('audioSeagullPlayer').volume =  document.getElementById('audioPlayer').volume;

        document.removeEventListener('click', musicPlay);

        window.addEventListener('click', onDocumentMouseDown, false);
    }

   
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    function onDocumentMouseDown( event ) {
        event.preventDefault();
       
        if (!clickMode){
            return
        }

        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
       
        raycaster.setFromCamera( mouse, camera );
       
        if (debugMode){
            console.log(scene.children);
        }

        const intersects = raycaster.intersectObjects( scene.children );
       
        if ( intersects.length > 0 ) {
            if (intersects[0].object.name != null){
                console.log("Clicked on: "+intersects[0].object.name);
            }
            if (typeof(intersects[0].object.callback) == 'function'){
                intersects[0].object.callback();
            }
        }
    }

//render loop
     var totalTime = 0;
    function animate() {

        if (loading){
            return
        }

        deltaTime = clock.getDelta();
     
        totalTime+=deltaTime;

        //controls.update();

        if (skyEmbedded!=null && skyEmbedded.visible) {

            if(skyTime == SkyTime.day) {
                skyEmbedded.material.map.offset.x -= 0.001*deltaTime; 
            }
            else {
                skyEmbedded.material.map.offset.x -= 0.001*deltaTime; 
                skyEmbedded.material.map.offset.y += 0.001*deltaTime; 
            }
        }
        
        if (waterUniforms!=null && water!=null) {
            waterUniforms[ 'time' ].value += 0.1*deltaTime;
        }

        if (boatGroup!=null) {
            if (boatGroup.parent == water){
                boatGroup.rotation.y += 0.02*deltaTime;
                boatGroup.position.z = Math.cos(totalTime)*0.05;
            }
            else if (boatGroup.parent==sea) {
             boatGroup.rotation.y += 0.02*deltaTime;
             boatGroup.position.z = Math.cos(totalTime)*0.05;
            } 
        }

        //Fireflies
        if (particlesEffects.length>0){
            const time = Date.now() * 0.00001;
            for ( let i = 0; i < particlesEffects.length; i ++ ) {
                particlesEffects[i].rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );
            }

            for ( let i = 0; i < particleMaterials.length; i ++ ) {
                const color = particleParameters[ i ][ 0 ];
                const h = ( 360 * ( color[ 0 ] + time ) % 360 ) / 360;
                particleMaterials[ i ].color.setHSL( h, color[ 1 ], color[ 2 ] );

            }
        }

        //Torchlights  animation
        for (const torch of torchLights){
            if (torch.light.visible){
                torch.mesh.material.uniforms["u_time"].value += deltaTime;
            }
        }
       
        //Phoenix animation
        if (phoenix!=null) {
            movePhoenixAroundPath(deltaTime*0.05);
        }

        //Leaves animation
        floatingObjects.forEach(obj => {
            obj.position.y+= Math.sin(obj.userData.delta + totalTime) * 0.001;
        });

        //Crab
        if (crab!=null)
        crab.lookAt(camera.position)

        requestAnimationFrame( animate );
        !postProcessingMode ? renderer.render( scene, camera ) : postProcessing.composer.render(deltaTime);
        TWEEN.update();

        stats.update()
    }

//Window listener

    window.addEventListener( 'resize', onWindowResize );
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

//Page loaded
    window.addEventListener('load', function() {
          //Stats
        stats = Stats()
        document.body.appendChild(stats.dom)

        //Renderer
        renderer = new THREE.WebGLRenderer({ antialias: antialiasMode,powerPreference: "high-performance" }); 
        renderer.setSize( window.innerWidth, window.innerHeight ); 
        renderer.shadowMap.enabled = shadowsMode;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        //renderer.powerPreference = "high-performance"
        renderer.autoClear = !postProcessingMode;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.LinearToneMapping;
        document.body.appendChild( renderer.domElement );

        //Scene
        scene = new THREE.Scene(); 

        //Camera
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 ); 
        camera.far = 100;
        camera.position.y = 1.57;
        camera.position.z = 10;
        camera.updateProjectionMatrix();

        //Camera Controls
        controls = new OrbitControls( camera, renderer.domElement );
        controls.keyPanSpeed = 10;
        controls.panSpeed = 1;
        controls.rotateSpeed = 1;
        controls.zoomSpeed = 1;
        controls.autoRotate = false;
        controls.minDistance = 5;
        controls.maxDistance = 10;
        controls.maxPolarAngle = THREE.MathUtils.degToRad(80); 
        //Must be called after any manual changes to the camera's transform
        controls.update() //mandatory
        controls.addEventListener("change", () => renderer.render(scene, camera));

    //Scene setup
        placeFog(scene,fogMode)

        //Global light
        ambientLight = new THREE.AmbientLight(0xffffff)
        ambientLight.intensity = 2;
        scene.add(ambientLight);

    //water
        if (waterMode){
            sky = placeSky(scene);
            sun = placeSun(sky,scene);
            water = placeWater(scene, sun);
        }

        //Local light
        spotLight = new THREE.SpotLight(0xd4d49c);
        spotLight.position.set(0, 5, 1.4);
        spotLight.castShadow = lightsShadow;
        spotLight.penumbra = 0.05;
        spotLight.intensity = 30;
        spotLight.distance = 6;
        spotLight.angle = 0.7;
        //spotLight.target = castle; //target has to be added before this command
        scene.add(spotLight);
        
        loadEnvironment()
    });

</script> 
<audio id="audioPlayer" autoplay loop>
    <source src="/audio/sea.ogg" type="audio/ogg">
    <embed src="/audio/sea.mp3" autostart="true" loop="true" hidden="true"> 
</audio>

<audio id="audioSeagullPlayer" autoplay loop>
    <source src="/audio/seagull.ogg" type="audio/ogg">
    <embed src="/audio/seagull.mp3" autostart="true" loop="true" hidden="true"> 
</audio>

<audio id="audioCricketsPlayer" loop>
    <source src="/audio/crickets.ogg" type="audio/ogg">
    <embed src="/audio/crickets.mp3" autostart="true" loop="true" hidden="true"> 
</audio>
</body>
</html>